package b_operation;

public class Operation_03 {
	public static void main(String[] args){
	/*
	1. 산술연산자
	  - 사칙연산자 (+,-,*,/), 나머지 연산자(%), 쉬프트 연산자(<<, >>, >>>)
	  - 두개의 피연산자를 취하는 이항연산자 이다.
	  - 두 피연산자 모두 4byte형보다 작은 경우, 둘다 4byte형인 int로 변환하여 연산을 수행한다.
	
	2. 사칙연산자 (+,-,*,/)
	  - 두개의 피연자중 하나이상이 4byte형보다 큰 경우에는 큰 자료형으로 변환 후 연산한다.
	    : int + float => float + float -> float
	  - 두 개의 피연산자 모두 4byte형보다 작은 경우에는 둘다 int형으로 변환 후 연산.
	    : byte + short -> int + int
	  - 정수형 간의 나눗셈에서 0으로 나누는 것은 금지되어 있다.

	*/
		
	//1. byte형 변수 b1 선언, 80으로 초기화
	byte b1 = 80;	
	//2. byte형 변수 b2 선언, 100으로 초기화
	byte b2 = 100;
	//3. long형 변수 lo1 선언, 642으로 초기화
	long lo1 = 642L;
	//4. lo1과 b1의 합을 변수 result1에 저장
	long result1 = lo1 + b1;
	//5. result1의 값을 출력
	System.out.println(result1);
	//6. b1과 b2의 합을 변수 result2에 저장
//	byte + byte => int + int -> int
	int result2 = b1 + b2;
	//7. result2의 값을 출력
	System.out.println(result2);
	//8. byte형 변수 result3을 선언하고 b1과 b2의 합으로 초기화
//	byte + byte = int + int => int
	byte result3 = (byte)(b1 + b2);
	//9. result3의 값을 출력
	System.out.println(result3); //오버플로우 발생해서 음수값이 나옴
	//10. 변수 lo2 선언, 60000과 80000의 곱을 저장.
//	long lo2 = 60000 * 80000; => int로 인식해서 오버플로우가 발생한 상태에서 연산됨
//	long lo2 = 60000L * 80000L;
	long lo2 = 60000L * 80000; //60000L하면 뒤에도 long으로 바뀌어서 연산잘됨
	//11. lo2에 저장된 값을 출력
	System.out.println(lo2);
	
	
	/*
	3. 나머지 연산자(%)
	  - 왼쪽의 피연산자를 오른쪽의 피연산자로 나누고 난 나머지 값을 반환하는 연산자.
	  - boolean형을 제외한 모든 기본형 변수에 사용할 수 있다.
	  - 0으로 나눌 수 없고, 두 피연산자 모두 정수만 허용
	  - 주로 짝수, 홀수 또는 배수 검사 등에 사용.
	*/
	
	// 사용자가 값을 두개를 주면 사용자가 원하는 숫자의 몫과 나머지 구하기
	int a1 = 94;
	int b3 = 11;
	
	int share = a1/b3;
	int remain = a1%b3;
		
	// xx을 xx로 나눈 몫은 x이고 나머지는 xx이다.
	System.out.println(a1+"을 "+b3+"로 "+"나눈 몫은 "
	+share+"이고 나머지는 "+remain+"이다.");//중간에 엔터쳐도됨 ;로 한줄구분하기때문
	
	
	/*
	4. 쉬프트 연산자 ( <<, >>, >>>)
	- 정수형 변수에만 사용이 가능하다.
	- 피연산자의 각자리(진수)를 오른쪽 또는 왼쪽으로 이동한다.
	- 곱셈과 나눗셈을 할 때 연산속도가 매우 뛰어나다.
	- << : x<<n -> x * 2^n
	- >> : x>>n -> x / 2^n
	- << : 큰 숫자 (은행권, 천문학) / >>> : 그래픽 흑백전환 
	*/
	
	int shift = 10; //long 으로도 실험해보기
	System.out.println(shift<<33); 
	System.out.println(shift>>3);
	
	/*
	5. 비교연산자
	  - 두 개의 변수 또는 리터럴을 비교하는데 사용된다.
	  - 주로 조건문과 반복문의 조건식에 사용되며 연산결과는 true 또는 false이다.
	  - 이항연산자이다
	
	6. 대소비교연산자 ( <, >, <=, >= )
	  - 기본 자료형중에 boolean을 제외한 나머지 자료형에 사용이 가능하다.
	  - 예) 참조형은 안됨: 주소 비교에 의미 없음
	  
	7. 등가비교연산자 ( ==, !=)
	  - 모든 자료형에 사용 가능
	  - 예) 기본: true, false 값이 같은지? 참조: 주소가 같은지?
	  
	  
	 	수식       |             연산결과
	 	x>y   | x가 y보다 클 때만 true, 그 외에는 false
	 	x<y   | x가 y보다 작을 때만 true, 그 외에는 false
	    x>=y  | x가 y보다 작거나 같을때만 true, 그 외에는 false
	    x<=y  | x가 y보다 크거나 같을때만 true, 그 외에는 false
	    x==y  | x와 y보다 같을 때만 true, 그 외에는 false
	    x!=y  | x와 y보다 다를 때만 true, 그 외에는 false
	    
	*/
	
	//책 p.38
	//1. 변수 f01 선언, 0.1f 로 초기화
	float f01 = 0.1f;
	//2. 변수 f02 선언, 10.0f 로 초기화
	float f02 = 10.0f;
	//3. 변수 do01 선언, 0.1 로 초기화
	double do01 = 0.1;
	//4. 변수 do02 선언, 10.0 로 초기화
	double do02 = 10.0;
	//5. 변수 str1 선언, "화이팅" 초기화
	String str1 = "화이팅";
	//6. "변수 f01과 do01의 값은 같은가?"의 결과를 출력
	//예상: 0.1뒤의 소수점..double이 더 정밀..근사치일뿐...그래서..false...?
	//해설: 더블타입은 2의 n승으로 표현이 됨(연산빠른데 근사치일뿐), float은 정확한 값
	//해설2: 둘다 2의n승으로 표현되는 값이면 true로 나온다
	System.out.println(f01 == do01);
	//7. "변수 f02과 do02의 값은 같은가?"의 결과를 출력
	//예상: 0은 딱 떨어지니까.. float과 double이 같아서.. true..?
	//해설: 0은 소수점뒤로 없으니까 근사치아니고 딱떨어져서 true
	System.out.println(f02 == do02); 
	//8. "str1의 값이 "화이팅"과 같은 값인가??"의 결과를 출력
	//예상: 등가비교연산자는 모든 자료형에 사용가능하니까?
	System.out.println(str1 == "화이팅");
	System.out.println(str1.equals("화이팅"));  // 두개 비교 다시 해보기
	
	/*
	8. 비트연산자 ( &, |, ^엑스오어, 익스클루시브 오어 )
	  - 비트가 나오면 2진수 바로 떠올리기
	  - 전기회로 만들 때 자주 만듬
	  - 이진비트연산을 수행한다.
	  - 실수형을 제외한 모든 곳에 사용가능하다. (실수는 우리가 알고있는 bit형 연산형태가 아니기때문. bit후 추가과정 필요)
	  | (OR연산)  - 피연산자중 한 쪽의 값이 1이면 1의 결과를 얻는다.
	  & (AND연산) - 피연산자 양쪽 모두 1이면 1의 결과를 얻는다.
	  ^ (XOR연산) - 피연산자의 값이 서로 다르면 1의 결과를 얻는다.
	*/
	
	int a = 3;
	int b = 5;
	
	System.out.println(a|b);
	System.out.println(a&b);
	System.out.println(a^b);
	
	
	/*
	9. 논리연산자 ( &&, || )
	  - 7 <= a <=20 (수학적 연산)
	  - 7 <= a 그리고 a <=20 (프로그래밍 연산)
	  - 피연산자로 boolean형 또는 boolean형 값을 결과로 하는 조건식만 허용한다.
	  - 조건식의 결합에 사용된다.
	  - '&&'이 '||'보다 연산 우선순위가 높다.
	  - ( && ) || ( &&) 안하고 && || && 해도 ||가 맨나중에 연산된다
	  - 비밀번호 16자, 대소문자 이런기준코드
	  
	  || (OR결합)  - 피연산자중 어느 한쪽만 true일 때 true의 결과를 얻는다
	  && (AND결합) - 피연산자중 양쪽 모두가 true일 때 true의 결과를 얻는다.
	*/
	
	int a2 = 7; 
	// 질문: 5 이상 15이하일 때 true 
	// 질문 요지 : 5 <= a2 <= 15
	// 코딩식으로: 5 <= a2 && a2 <= 15  //이런 단계를 거쳐서 문제 풀 것
	System.out.println(5 <= a2 && a2 <= 15);
	
	
	//책 p.40 (2-11)
	//1. 변수 ch01 선언, 원하는 문자로 초기화
	char ch01 = 'A';
	
	//2. 변수 ch01의 값이 영어 대문자일 때 true인 조건식
	//'A' <= ch01 <= 'Z'
	//'A' <= ch01 그리고 ch01 <= 'Z'
	System.out.println('A' <= ch01 && ch01 <= 'Z'); //true
	
	//3. 변수 ch01의 값이 영어 소문자일 때 true인 조건식
	//'a' <= ch01 <= 'z'
	//'a' <= ch01 그리고 ch01 <= 'z'
	System.out.println('a' <= ch01 && ch01 <= 'z'); //false -> A는 이범위에 있지 않음
	
	//4. 변수 ch01의 값이 영문자일 때 true인 조건식
	// 영문자 = 대문자 or 소문자
	// 'A' <= ch01 <= 'Z' 또는 'a' <= ch01 <= 'z'
	// ('A' <= ch01 && ch01 <= 'Z') || ('a <= ch01 && ch01 <= 'z')
	System.out.println(('A' <= ch01 && ch01 <= 'Z') || ('a' <= ch01 && ch01 <= 'z'));
	
	//5. 변수 ch01의 값이 ASCII값 숫자 때 true인 조건식
	//'0<= ch01 <= '9' (그냥 0,9가 아니고 ASCII코드 숫자값이니까 ''붙여줌)
	//'0' <= ch01 그리고 ch01 <= '9'
	System.out.println('0' <= ch01 && ch01 <= '9');
	
//	//ascii코드값 숫자범위 -- 이건 ASCII를 알아야 만들 수 있으니까 의미없는 코드임
//	//0 <= ch01 <= 2^7-1
//	//0 <= ch01 && ch01 <=127
//	System.out.println(0 <= ch01 && ch01 <= 127); //'A' = false , 65=true
	
	/*
	10. 삼항연산자
	  - 세 개의 피연산자를 필요로 하기 때문에 삼항연산자로 이름지어졌다.
	  - 삼항연산자의 조건식에는 연산결과가 되어야한다
	  - 삼항연산자 안에 삼항연산자 들어갈 수 있음 (제한x)
	  - 기본구조
	    (조건식) ? true일때 수행 : fasle일때 수행 //기본적으로 경우의 수가 2개 (t/f)
	*/
	
	int a3 = -10;
	
	int abs = a3 >= 0 ? a3 : -a3; // true와 false안에 들어가는 애들 타입 일치되어야함
	System.out.println(abs); // 절댓값 구하는 프로그래밍
	
	/*
	11. 대입연산자 ( =, op= )
	  - 변수에 값 또는 수식의 연산결과를 저장하는데 사용한다.
	  - 연산자 중 연산우선순위가 가장 낮다.
	*/
	
	int b4 = 10;
	
	//1. b4의 값에 3을 곱한 결과를 b4에 저장해 주세요
	b4 = b4 * 3;          //얜 인트니까 상관없는데 char면 아래와같이 캐스팅해줘야됨
	b4 *= 3; 
//	int b4 *= 3; 선언과 동시에 못함
	
	char c3 = 'A';
//	c3 = (char)(c3+5);
	c3 += 5;  //위에거랑 같은거
//	c3 += 5+3; 이건 안되는거
	
	
	//반올림
	
	
	
	
	
	//랜덤
	
	//책 44쪽 2-13
	//1. 변수 x 선언, 0이상 100미만 사이의 임의의 정수 값으로 초기화
	//0 <= Math.random() < 1
	//구하려는거 0 <= x < 100
	//0*100 <= Math.random()*100 <1*100
	//0 <= Math.random()*100 <100
	//Math.random은 double값 이니 임의의 정수값을 구하기위해 int로 캐스팅
	int x = (int)(Math.random()*100);
			
	//2. x에 저장된 값 출력
	System.out.println(x);
	
	//3. 변수 x2 선언, 43초과 375미만 사이 정수의 값으로 초기화
	//0 <= Math.random() < 1
	//구하려는 거 43 < x2 < 375 
	//43초과면 44부터는 포함이니까 44<= 으로 바꾼다
	//44 <= x2 < 375 
	//0*331+44 <= Math.random()*331+44 < 1*331+44
	//Math.random()은 double값 이니 임의의 정수값 구하기위해 int로 캐스팅
	int x2 = (int)(Math.random()*331+44);
	
	//4. x2에 저장된 값 출력
	System.out.println(x2);
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
		
		
		
		
		
	}
}
